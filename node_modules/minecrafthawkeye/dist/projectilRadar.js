"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stopRadar = exports.startRadar = exports.getBotBoxes = exports.detectAim = exports.botBoxTall = void 0;
var _detectCollisions = require("detect-collisions");
var _loadBot = require("./loadBot");
var _types = require("./types");
var _calculateArrowTrayectory = require("./calculateArrowTrayectory");
var _mathHelper = require("./mathHelper");
var _hawkEye = require("./hawkEye");
let listening = false;
const DISTANCE_VISION = 100;
const radar = () => {
  const detectedEntities = detectAim();
  const botBoxes = getBotBoxes();
  let prevArrow;
  Object.values(detectedEntities).forEach(e => {
    prevArrow = undefined;
    e.prevTrajectory.forEach(arrowTrajectory => {
      if (!prevArrow) {
        prevArrow = arrowTrajectory;
        return;
      }
      const colission = (0, _mathHelper.calculateImpactToBoundingBox)(prevArrow, arrowTrajectory, botBoxes);
      if (colission) {
        _loadBot.bot.emit('target_aiming_at_you', e.entity, e.prevTrajectory);
      }
      prevArrow = arrowTrajectory;
    });
  });
  const projectiles = (0, _hawkEye.detectProjectiles)();
  projectiles.forEach(p => {
    if (p.previusPositions.length < 2) return;
    const lastItem = p.previusPositions[p.previusPositions.length - 1];
    const lastItem2 = p.previusPositions[p.previusPositions.length - 2];
    if (lastItem.pos.equals(lastItem2.pos)) {
      return;
    }
    const yaw = (0, _mathHelper.calculateYaw)(lastItem2.pos, lastItem.pos);
    const pitch = (0, _mathHelper.calculayePitch)(lastItem2.pos, lastItem.pos);
    const arrowTrajectoryPoints = _loadBot.bot.hawkEye.calculateArrowTrayectory(lastItem.pos, p.currentSpeed, pitch, yaw, _types.Weapons.bow).arrowTrajectoryPoints;
    if (arrowTrajectoryPoints.length < 2) return;
    for (let pi = 1; pi < arrowTrajectoryPoints.length; pi++) {
      const prevousArrow = arrowTrajectoryPoints[pi - 1];
      const currentArrow = arrowTrajectoryPoints[pi];
      const colission = (0, _mathHelper.calculateImpactToBoundingBox)(prevousArrow, currentArrow, botBoxes);
      if (colission) {
        _loadBot.bot.emit('incoming_projectil', p, arrowTrajectoryPoints);
        return;
      }
    }
  });
};
const detectAim = () => {
  const system = new _detectCollisions.System();
  const {
    boxXZ
  } = (0, _mathHelper.getBoxes)(getBotBoxes());
  const entities = Object.values(_loadBot.bot.entities)
  // @ts-ignore metadata loading bow
  .filter(e => e.type === "player" && (e.metadata[8] === 1 || e.metadata[8] === 3) /* Is loading bow */ || e.type === 'mob' && e.name === 'skeleton').filter(e => {
    if (e.name === 'skeleton' && e.position.distanceTo(_loadBot.bot.entity.position) > 16) return false;
    if (e.name === 'skeleton' && e.position.distanceTo(_loadBot.bot.entity.position) <= 16) return true;
    const eyePosition = e.position.offset(0, 1.6, 0);
    const lookingAt = (0, _mathHelper.calculateDestinationByYaw)(eyePosition, e.yaw + Math.PI, DISTANCE_VISION);
    const rayXZStart = {
      x: eyePosition.x,
      y: eyePosition.z
    };
    const rayXZEnd = {
      x: lookingAt.x,
      y: lookingAt.z
    };
    const ray = new _detectCollisions.Line(rayXZStart, rayXZEnd);
    const colisionXZ = system.checkCollision(ray, boxXZ);
    return colisionXZ;
  });
  const calculatedEntityTarget = {};
  entities.forEach(e => {
    if (!e.uuid) return;
    const calc = (0, _calculateArrowTrayectory.calculateArrowTrayectory)(e.position.offset(0, 1.6, 0), 3, e.pitch, e.yaw, _types.Weapons.bow);
    calculatedEntityTarget[e.uuid] = {
      uuid: e.uuid,
      entity: e,
      name: e.type === "player" ? e.username ?? '' : e.name ?? '',
      prevTrajectory: calc.arrowTrajectoryPoints
    };
  });
  return calculatedEntityTarget;
};
exports.detectAim = detectAim;
const getBotBoxes = () => {
  return {
    start: _loadBot.bot.entity.position.offset(-1, -0.5, -1),
    end: _loadBot.bot.entity.position.offset(1, 2.5, 1)
  };
};
exports.getBotBoxes = getBotBoxes;
const botBoxTall = () => {
  return new _detectCollisions.Box({
    x: _loadBot.bot.entity.position.x - 1,
    y: _loadBot.bot.entity.position.y - 1.6
  }, 2, 2.4);
};
exports.botBoxTall = botBoxTall;
const startRadar = () => {
  if (listening) return;
  listening = true;
  _loadBot.bot.on('physicsTick', radar);
};
exports.startRadar = startRadar;
const stopRadar = () => {
  if (!listening) return;
  _loadBot.bot.removeListener('physicsTick', radar);
  listening = false;
};
exports.stopRadar = stopRadar;