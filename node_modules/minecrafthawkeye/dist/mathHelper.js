"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.radiansToDegrees = exports.getVoy = exports.getVox = exports.getVo = exports.getTargetDistance = exports.getBoxes = exports.degreesToRadians = exports.calculayePitch = exports.calculateYaw = exports.calculateRayCast = exports.calculateImpactToBoundingBox = exports.calculateDestinationByYaw = exports.calculateDestinationByPitch = exports.calculateAngle = exports.applyGravityToVoy = void 0;
var _detectCollisions = require("detect-collisions");
const getTargetDistance = (origin, destination) => {
  const xDistance = Math.pow(origin.x - destination.x, 2);
  const zDistance = Math.pow(origin.z - destination.z, 2);
  const hDistance = Math.sqrt(xDistance + zDistance);
  const yDistance = destination.y - origin.y;
  const distance = Math.sqrt(Math.pow(yDistance, 2) + xDistance + zDistance);
  return {
    distance,
    hDistance,
    yDistance
  };
};
exports.getTargetDistance = getTargetDistance;
const calculateAngle = (from, to) => {
  const xDistance = to.x - from.x;
  const yDistance = to.y - from.y;
  const yaw = Math.atan2(xDistance, yDistance) + Math.PI;
  return yaw;
};
exports.calculateAngle = calculateAngle;
const calculateYaw = (from, to) => {
  const yaw = calculateAngle({
    x: from.x,
    y: from.z
  }, {
    x: to.x,
    y: to.z
  });
  return yaw;
};
exports.calculateYaw = calculateYaw;
const calculateDestinationByYaw = (origin, yaw, distance) => {
  const x = distance * Math.sin(yaw);
  const z = distance * Math.cos(yaw);
  return origin.offset(x, 0, z);
};
exports.calculateDestinationByYaw = calculateDestinationByYaw;
const calculateDestinationByPitch = (origin, pitch, distance) => {
  const y = distance * Math.sin(pitch);
  return origin.offset(0, y, 0);
};
exports.calculateDestinationByPitch = calculateDestinationByPitch;
const calculateRayCast = (origin, pitch, yaw, distance) => {
  const x = distance * Math.sin(yaw) * Math.cos(pitch);
  const y = distance * Math.sin(pitch);
  const z = distance * Math.cos(yaw) * Math.cos(pitch);
  return origin.offset(x, y, z);
};
exports.calculateRayCast = calculateRayCast;
const calculayePitch = (origin, destination) => {
  const {
    hDistance,
    yDistance
  } = getTargetDistance(origin, destination);
  const pitch = Math.atan2(yDistance, hDistance);
  return pitch;
};
exports.calculayePitch = calculayePitch;
const degreesToRadians = degrees => {
  return degrees * Math.PI / 180;
};
exports.degreesToRadians = degreesToRadians;
const radiansToDegrees = radians => {
  return radians * (180 / Math.PI);
};
exports.radiansToDegrees = radiansToDegrees;
const getVox = (Vo, Alfa, Resistance = 0) => {
  return Vo * Math.cos(Alfa) - Resistance;
};
exports.getVox = getVox;
const getVoy = (Vo, Alfa, Resistance = 0) => {
  return Vo * Math.sin(Alfa) - Resistance;
};
exports.getVoy = getVoy;
const getVo = (Vox, Voy, G) => {
  return Math.sqrt(Math.pow(Vox, 2) + Math.pow(Voy - G, 2)); // New Total Velocity - Gravity
};
exports.getVo = getVo;
const applyGravityToVoy = (Vo, Voy, Gravity) => {
  // radians
  return Math.asin((Voy - Gravity) / Vo);
};
exports.applyGravityToVoy = applyGravityToVoy;
const getBoxes = boxIn => {
  const boxXZ = new _detectCollisions.Box({
    x: boxIn.start.x,
    y: boxIn.start.z
  }, Math.abs(boxIn.start.x - boxIn.end.x), Math.abs(boxIn.start.z - boxIn.end.z));
  const boxXY = new _detectCollisions.Box({
    x: boxIn.start.x,
    y: boxIn.start.y
  }, Math.abs(boxIn.start.x - boxIn.end.x), Math.abs(boxIn.start.y - boxIn.end.y));
  const boxZY = new _detectCollisions.Box({
    x: boxIn.start.z,
    y: boxIn.start.y
  }, Math.abs(boxIn.start.z - boxIn.end.z), Math.abs(boxIn.start.y - boxIn.end.y));
  return {
    boxXZ,
    boxXY,
    boxZY
  };
};
exports.getBoxes = getBoxes;
const calculateImpactToBoundingBox = (from, to, box) => {
  const system = new _detectCollisions.System();
  const {
    boxXZ,
    boxXY,
    boxZY
  } = getBoxes(box);
  const rayXZStart = {
    x: from.x,
    y: from.z
  };
  const rayXZEnd = {
    x: to.x,
    y: to.z
  };
  const rayXYStart = {
    x: from.x,
    y: from.y
  };
  const rayXYEnd = {
    x: to.x,
    y: to.y
  };
  const rayZYStart = {
    x: from.z,
    y: from.y
  };
  const rayZYEnd = {
    x: to.z,
    y: to.y
  };
  if (rayXZStart.x === rayXZEnd.x && rayXZStart.y === rayXZEnd.y || rayXYStart.x === rayXYEnd.x && rayXYStart.y === rayXYEnd.y || rayZYStart.x === rayZYEnd.x && rayZYStart.y === rayZYEnd.y) {
    return false;
  }
  const rayXZ = new _detectCollisions.Line(rayXZStart, rayXZEnd);
  const rayXY = new _detectCollisions.Line(rayXYStart, rayXYEnd);
  const rayZY = new _detectCollisions.Line(rayZYStart, rayZYEnd);
  const colisionXZ = system.checkCollision(rayXZ, boxXZ);
  const colisionXY = system.checkCollision(rayXY, boxXY);
  const colisionZY = system.checkCollision(boxZY, rayZY);
  const all = colisionXZ === true && colisionXY === true && colisionZY === true;
  return all;
};
exports.calculateImpactToBoundingBox = calculateImpactToBoundingBox;