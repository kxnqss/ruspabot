"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stop = exports.detectProjectiles = exports.autoAttack = void 0;
var _types = require("./types");
var _vec = require("vec3");
var _hawkEyeEquations = _interopRequireDefault(require("./hawkEyeEquations"));
var _uuid = require("uuid");
var _loadBot = require("./loadBot");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let target;
let preparingShot;
let preparingShotTime;
let prevPlayerPositions = [];
let oneShot;
let chargingArrow;
let weapon = _types.Weapons.bow;
let infoShot;
const autoAttack = (targetToAttack, inputWeapon = _types.Weapons.bow, isOneShot = false) => {
  if (!targetToAttack) {
    return false;
  }
  oneShot = isOneShot;
  target = targetToAttack;
  preparingShot = false;
  prevPlayerPositions = [];
  weapon = inputWeapon;
  _loadBot.bot.on('physicsTick', getGrades);
  _loadBot.bot.on('physicsTick', autoCalc);
  return true;
};
exports.autoAttack = autoAttack;
const stop = () => {
  _loadBot.bot.deactivateItem();
  _loadBot.bot.removeListener('physicsTick', getGrades);
  _loadBot.bot.removeListener('physicsTick', autoCalc);
  _loadBot.bot.emit('auto_shot_stopped', target);
};
exports.stop = stop;
const getGrades = () => {
  if (target === undefined || (0, _types.isEntity)(target) && !target.isValid) {
    stop();
    return;
  }
  if (prevPlayerPositions.length > 10) {
    prevPlayerPositions.shift();
  }
  const position = target.position.clone();
  prevPlayerPositions.push(position);
  const speed = new _vec.Vec3(0, 0, 0);
  for (let i = 1; i < prevPlayerPositions.length; i++) {
    const pos = prevPlayerPositions[i];
    const prevPos = prevPlayerPositions[i - 1];
    speed.x += pos.x - prevPos.x;
    speed.y += pos.y - prevPos.y;
    speed.z += pos.z - prevPos.z;
  }
  speed.x = speed.x / prevPlayerPositions.length;
  speed.y = speed.y / prevPlayerPositions.length;
  speed.z = speed.z / prevPlayerPositions.length;
  infoShot = (0, _hawkEyeEquations.default)(target, speed, weapon);
};
const autoCalc = async () => {
  const waitTime = _types.weaponsProps[weapon].waitTime;
  const slotID = _loadBot.bot.getEquipmentDestSlot('hand');
  if (_loadBot.bot.inventory.slots[slotID] === null || _loadBot.bot.inventory.slots[slotID]?.name !== weapon) {
    const weaponFound = _loadBot.bot.inventory.items().find(item => item.name === weapon);
    if (weaponFound) {
      try {
        await _loadBot.bot.equip(weaponFound, 'hand');
        return;
      } catch (err) {
        await sleep(500);
        return;
      }
    } else {
      stop();
      return;
    }
  }
  if (!preparingShot) {
    if (['bow', 'crossbow', 'trident'].includes(weapon)) {
      _loadBot.bot.activateItem();
    }
    preparingShot = true;
    preparingShotTime = Date.now();
  }
  if (infoShot) {
    _loadBot.bot.look(infoShot.yaw, infoShot.pitch, true);
    if (preparingShot) {
      if (['bow', 'trident'].includes(weapon) && Date.now() - preparingShotTime > waitTime) {
        _loadBot.bot.deactivateItem();
        preparingShot = false;
        if (oneShot) {
          stop();
        }
      }
      if (['snowball', 'ender_pearl', 'egg', 'splash_potion'].includes(weapon) && Date.now() - preparingShotTime > waitTime) {
        _loadBot.bot.swingArm('left');
        _loadBot.bot.activateItem();
        _loadBot.bot.deactivateItem();
        preparingShot = false;
        if (oneShot) {
          stop();
        }
      }
      if (weapon === 'crossbow') {
        shotCrossbow();
      }
    }
  }
};
const shotCrossbow = () => {
  if (chargingArrow) {
    _loadBot.bot.activateItem();
    _loadBot.bot.deactivateItem();
    chargingArrow = false;
    preparingShot = false;
    if (oneShot) {
      stop();
    }
    return;
  }
  if (_loadBot.bot.heldItem === null) {
    stop();
    return;
  }

  // @ts-ignore pending to fix types from core
  const isEnchanted = _loadBot.bot.heldItem.nbt.value.Enchantments ? _loadBot.bot.heldItem.nbt.value.Enchantments.value.value.find(enchant => enchant.id.value === 'quick_charge') : undefined;
  const shotIn = 1250 - (isEnchanted ? isEnchanted.lvl.value : 0) * 250;
  if (weapon === 'crossbow' && !chargingArrow && Date.now() - preparingShotTime > shotIn) {
    _loadBot.bot.deactivateItem();
    chargingArrow = true;
  }
};
const sleep = ms => {
  return new Promise(resolve => setTimeout(resolve, ms));
};
const currentProjectileDetected = {};
const detectProjectiles = (projectile = 'arrow') => {
  const ArrayEntities = Object.values(_loadBot.bot.entities);
  const projectiles = ArrayEntities.filter(e => e.name === projectile && e.type === "projectile");
  const updatedAt = Date.now();
  projectiles.forEach(e => {
    if (!e.uuid) {
      e.uuid = (0, _uuid.v4)();
    }
    if (!currentProjectileDetected[e.uuid]) {
      currentProjectileDetected[e.uuid] = {
        uuid: e.uuid,
        entity: e,
        enabled: true,
        currentSpeed: 0,
        currentSpeedTime: Date.now(),
        previusPositions: [],
        updatedAt
      };
    } else {
      currentProjectileDetected[e.uuid].updatedAt = updatedAt;
    }

    // if (currentProjectileDetected[e.uuid].previusPositions.length > 3) { currentProjectileDetected[e.uuid].previusPositions.shift() }
    currentProjectileDetected[e.uuid].previusPositions.push({
      at: Date.now(),
      pos: e.position.clone()
    });
  });
  Object.entries(currentProjectileDetected).forEach(e => {
    const [uuid, arrow] = e;
    if (arrow.updatedAt !== updatedAt) {
      delete currentProjectileDetected[uuid];
    }
  });
  const arrowsInAir = [];
  Object.entries(currentProjectileDetected).filter(e => e[1].enabled).forEach(e => {
    const [uuid, projectil] = e;
    const speed = new _vec.Vec3(0, 0, 0);
    const previusPositions = projectil.previusPositions;
    const totalItemsToCatch = 3;
    const start = previusPositions.length >= totalItemsToCatch ? previusPositions.length - totalItemsToCatch : 0;
    const previusPositionsTocheck = previusPositions.slice(start);
    for (let i = 1; i < previusPositionsTocheck.length; i++) {
      const pos = previusPositionsTocheck[i];
      const prevPos = previusPositionsTocheck[i - 1];
      speed.x += Math.abs(pos.pos.x - prevPos.pos.x);
      speed.y += Math.abs(pos.pos.y - prevPos.pos.y);
      speed.z += Math.abs(pos.pos.z - prevPos.pos.z);
    }
    speed.x = speed.x / previusPositionsTocheck.length;
    speed.y = speed.y / previusPositionsTocheck.length;
    speed.z = speed.z / previusPositionsTocheck.length;
    const currentSpeed = speed.x + speed.y + speed.z;
    if (currentSpeed !== projectil.currentSpeed) {
      projectil.currentSpeed = currentSpeed <= 3 ? currentSpeed : 3;
      projectil.currentSpeedTime = Date.now();
    }
    if (projectil.currentSpeed === 0 && Date.now() - projectil.currentSpeedTime > 1500) {
      projectil.enabled = false;
    } else {
      arrowsInAir.push(projectil);
    }
  });
  return arrowsInAir;
};
exports.detectProjectiles = detectProjectiles;