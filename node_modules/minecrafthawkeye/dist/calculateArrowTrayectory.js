"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateArrowTrayectory = void 0;
var _vec = require("vec3");
var _constants = require("./constants");
var _types = require("./types");
var _intercept = require("./intercept");
var _mathHelper = require("./mathHelper");
const calculateArrowTrayectory = (currentPos, itemSpeed, pitch, yaw, ammunitionType) => {
  const weapon = ammunitionType ?? _types.Weapons.bow;
  if (!Object.keys(_types.Weapons).includes(weapon)) {
    throw new Error(`${weapon} is not valid to calculate the trayectory!`);
  }
  const weaponGravity = _types.weaponsProps[weapon].GRAVITY;
  const res = staticCalc(currentPos, weaponGravity, pitch, yaw, itemSpeed);
  return res;
};
exports.calculateArrowTrayectory = calculateArrowTrayectory;
const staticCalc = (initialArrowPosition, gravityIn, pitch, yaw, VoIn, precision = 1) => {
  let Vo = VoIn;
  const gravity = gravityIn / precision;
  const factorY = _constants.FACTOR_Y / precision;
  const factorH = _constants.FACTOR_H / precision;
  let Voy = (0, _mathHelper.getVoy)(Vo, pitch); // Vector Y
  let Vox = (0, _mathHelper.getVox)(Vo, pitch); // Vector X
  let Vy = Voy / precision;
  let Vx = Vox / precision;
  let Alfa;
  let totalTicks = 0;
  let blockInTrayect = null;
  const arrowTrajectoryPoints = [];
  arrowTrajectoryPoints.push(initialArrowPosition);
  while (true) {
    totalTicks += 1 / precision;
    Vo = (0, _mathHelper.getVo)(Vox, Voy, gravity);
    Alfa = (0, _mathHelper.applyGravityToVoy)(Vo, Voy, gravity);
    Voy = (0, _mathHelper.getVoy)(Vo, Alfa, Voy * factorY);
    Vox = (0, _mathHelper.getVox)(Vo, Alfa, Vox * factorH);
    Vy += Voy / precision;
    Vx += Vox / precision;
    const x = initialArrowPosition.x - Math.sin(yaw) * Vx;
    const z = yaw === 0 ? initialArrowPosition.z : initialArrowPosition.z - Math.sin(yaw) * Vx / Math.tan(yaw);
    const y = initialArrowPosition.y + Vy;
    const currentArrowPosition = new _vec.Vec3(x, y, z);
    arrowTrajectoryPoints.push(currentArrowPosition);
    const previusArrowPositionIntercept = arrowTrajectoryPoints[arrowTrajectoryPoints.length === 1 ? 0 : arrowTrajectoryPoints.length - 2];
    blockInTrayect = (0, _intercept.check)(previusArrowPositionIntercept, currentArrowPosition);
    if (blockInTrayect !== null) {
      return {
        totalTicks,
        blockInTrayect,
        arrowTrajectoryPoints
      };
    }
  }
};